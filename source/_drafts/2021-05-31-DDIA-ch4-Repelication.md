---
title: DDIA-ch5-Repelication
date: 2021-05-31 21:56:54
tags: 
    - 讀書心得
---

# Repelication: 複製

出於以下理由，我們希望能複製數據：
- 讓數據和用戶在地理位置上接近(減少延遲性)
- 部分數據出現故障，系統也能持續進行(高可用性)
- 伸縮可以接受請求的機器數(提高吞吐量)

本章僅討論每個機器可以保存完整備份的情況，對單個機器來說太大量的資料(需要分割數據)的部分會在第六章中進行。

僅此一次的複製很簡單，複製的困難處在資料變更上，如何追蹤不同機器備份的一致性?
以下將討論3種流行的變更算法，幾乎所有的分布式資料庫都使用這三種算法：

- 單領導者(single leader)
- 多領導者(multi leader)
- 無領導者(leaderless)

複製的時候同樣需要利弊權衡，例如要使用同步還是異步? 如何處理失敗的劇本? 如何處理多節點資料庫? 這些通常會因不同資料庫而異，在之後同樣會討論這些決策的結果。

<!--more-->

## 領導者和跟隨者 (Leader and follower)

儲存資料庫的每個節點稱為複本(replica)，每一次往資料庫寫入都需要傳播到所有複本上，否則複本就會包含不一致的數據。最常見的方案為基於領導者的複製(leader-based replication)，也稱為主動/被動(active/passive) 或 主從(master/slave) 複製，工作原理如下:

1. 複本之一被指定為leader，也稱為master/primary，當client端寫入時，將請求發給leader，leader會將新數據寫入本地存儲。

2. 其他複本被稱為followers，也叫read replicas/slaves/secondaries/hot-standby。當leader將新數據寫入本地時，也會將數據變更送給所有followers，稱為複製日志(replication log)或變更流(change stream)。每個follower 跟隨 leader 拉取日志，並根據相對應的方法處理同樣順序的所有寫入。

3. 當client想讀取資料時，可以向leader/follower查詢，但只有leader 接受寫入操作

![基於領導者的主從複製](https://github.com/Vonng/ddia/raw/master/img/fig5-1.png)

這種模式被廣泛的應用，例如:
Relational Database: PostgresSQL, MySQL, Oracle Data Guard, SQL Server的AlwaysOn
Nonrelational Database: MongoDB, RethinkDB, Espresso
Distributed Messages Broker: Kafka, RabbitMQ
Network filesystem: DRBD

## 同步複製和異步複製 (Synchronous Versus Asynchronous Replication)

複製系統的另一個細節是，複製是同步(synchronous)還是異步(asynchronous)。在關聯式資料庫通常可以選擇要哪個，其他系統則是直接寫死成其中一個。

![基於領導者的複製:　一個同步follower和一個異步follower](https://github.com/Vonng/ddia/raw/master/img/fig5-2.png)

想像發生的情況: 網站的用戶更新個人頭像，先向leader發送請求，leader收到請求，leader將轉變發送給followers，最後leader通知用戶更新成功。

follower1的複製是同步的：在向用戶報告寫入成功並使結果讓其他用戶可見，leader需要等待follower1確認，確保1已經收到寫入請求；follower2是異步的，leader發送訊息但不等follower2回應。

在這張圖中，follower2存在一個顯著的延遲。通常情況下複製都很快，大多數follower資料庫能在1秒內改變，但他們不能提供複製用時的保證。有些情況下會落後leader數分鐘或更久，例如故障恢復或節點間存在網路問題。

同步複製的優點是和leader保持一致，如果leader爆炸，可以從follower上找回數據；缺點是如果同步的那台follower沒有反應(崩潰，網路故障等等)，leader就無法進行任何寫入操作。leader必須停止所有寫入，並等待同步的follower恢復。

因此如果將所有follower都設置為同步，任何一台follower出問題都會導致整個系統停擺。實際上如果在資料庫啟用同步複製，通常是一台同步，其他台異步，當同步的那台出問題時，將異步的其中一台轉為同步。這至少保證在兩個節點上有最新的副本，這種配置也被稱為辦同步(semi-synchronus)。

通常情況下，基於領導者的複製都配置為完全異步，這種情況下如果leader出問題，責任何未複製到follower的資料會丟失，意味著即使客戶端確認寫入成功，寫入也不能保證持久(durable)。全異步的優點是，即使所有follower都落後，leader仍然可以持續寫入。

參照: 
- [鏈式複製](https://zhuanlan.zhihu.com/p/219797965)
- [MVCC](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)
- [複製方法](https://zhuanlan.zhihu.com/p/34841946)

## 增加follower 

如何確保新的follower有leader的精確副本？不可能鎖定leader無法寫入，這樣違反高可用性的目標。

以概念上來說，大概如下:
1. 獲得某個時刻leader的一致性快照，而不用鎖定leader。大多數資料庫都有這種功能。
2. 將快照複製到新節點。
3. follower連接到leader，並拉取快照後的所有更新。這要求快照與leader複製日誌的位置精確關聯。不同資料庫有不同的名字，例如PostgreSQL稱為日誌序列號(log sequence number, LSN)，MySQL稱為二進制日誌座標(binlog coordinates)。
4. 處理完3後就算趕上leader了，之後繼續follow leader就好。

## 處理節點延宕

目標是即使單個節點故障，也能保持整個系統運作，盡可能控制節點停機造成的影響。

### follower失效: 追趕恢復
看是要開新的還是網路中斷後，都可以從日誌中知道最後一次事務，讓這台連接到leader後就可以繼續接收日誌。

### leader失效: 故障切換
其中一個follower會被升級為leader，client端需要將寫入操作發送至這台主機，其他follower需要開始拉這台的數據變化，稱為故障切換(**failover**)。

故障切換可以手動進行或是自動進行，自動進行通常由以下幾個步驟組成:

1. 確認leader失效。大多數系統都使用超時(Timeout)來確定，節點一段時間沒回應就認為它掛了。
2. 選擇一個新的leader。這可以透過選舉過程，或者可以由之前選定的控制器節點(controller node)來指定新的庫，leader的最佳候選人通常是擁有最新資料副本的follower(最小數據化資料損失)，讓所有節點同意一個新的leader，是一個共識性問題。
3. 重新配置系統後客戶端需要將寫入請求發給新leader。如果老leader回來，可能仍然覺得自己是leader，系統需要確保老leader認可新leader成為follower。

故障切換可能會出現以下問題:
- 新舊leader間的資料衝突: 使用異步複製的話，新leader可能沒有收到最後的資料，當老leader復原時，這些差異該如何處理? 最見單的就是丟棄老leader的資料，會損失資料的持久性。
- 兩個資料庫都以為自己是leader: 如果兩個leader都允許寫入卻沒有衝突解決機制，資料就可能丟失或損壞。一些系統有安全防範措施來隔離這些節點，稱為**STONITH**。
- 超時應該訂多久時間? : 太常資料丟失多，太短又會造成不必要的故障切換，尤其在系統已經高負載或是出現網路問題時切換，會造成情況更糟糕。

副本的一致性、持久性、可用性、和延遲的權衡，是分散式系統會碰到的問題。

## 複製日誌的實現

以下為幾種方法:

### 基於語句的複製

最簡單，leader紀錄每個寫入請求，然後把語句發送給follower，包含INSERT、UPDATE、DELETE。很簡單但是會出現一些問題:
- 任何使用非確定性的函數，ex NOW()，UUID()
- 有欄位用了auto increment，或者依賴資料庫中的現有資料(UPDATE ... WHERE ...)，必須保證在所有副本上執行順序都一樣，當有多個併發時可能成為一種限制。
- 有副作用的語句(ex  triggers, stored procedures)

的確有方法繞開這些問題，例如當語句被紀錄時，leader可以用固定的返回值替換任何不確定的函數調用。這種複製在5.1版前的MySQL使用，現在，但在默認情況下，MySQL會切換到基於行的複製。VoltDB還使用這種方法，但要求事務必須確定，以此來保證安全。

### WAL (預寫式日誌)

通常寫操作會附加到日誌中:
- 日誌是主要的儲存位置，日誌段在後台壓縮
- 對於複寫單個磁碟的B樹，每次修改都會寫入預寫式日誌(Write Ahead Log)，以便崩潰後可以恢復到一致 

在任何情況下，日誌都包含所有資料庫寫入的追加自結，可以使用完全相同的日誌在另一個節點上建構副本，除了將日誌寫入磁碟外，leader可以透過網路發給其他follower。

PostgreSQL 和 Oracle等使用這種複製方法。主要缺點是複製和儲存引擎緊密耦合，如果資料庫將其除純格式由異版更動到另一版，通常不可能再leader和follower上運行不同的版本。這點可能會對運維造成巨大影響，如果複製協議允許follower使用比leader更新的版本，則可以先升級follower後執行故障切換，使follower成為新的leader，從而實現資料庫的零停機升級。如果複製協議不允許版本不同(WAL常常都不允許)，則此類升級都需要停機。


### 邏輯日誌複製 (基於行)

另一種方法式，複製和儲存引擎使用不同的日誌格式，這樣可以使複製日誌從儲存引擎內部分離出來。關係性資料庫的邏輯日誌通常是以行的粒度描述紀錄序列:

- 對於INSERT:　日誌包含所有列的新值
- 對於DELETE:　日誌包含primary key標示，如果沒有primary key，則需要記錄所有列的舊值。
- 對於UPDATE:　日誌包含primary key標示，以及所有列的新值(或至少所有已經更變的新值)

修改多行的事務會產生多個這樣的日誌紀錄，後面跟個一條紀錄指出事務已經提交。MySQL使用這種方法。

由於邏輯日誌和儲存引擎內部分離，因此可以更容易地保持向後兼容，使leader和follower可以運行不同版本的資料庫甚至不同的儲存引擎。

對於外部應用來說，邏輯日誌也更容易解析。如果要將資料庫的內容發送到外部系統，這點很有用，例如CDC(change data capture)就會應用到。

### 基於Trigger 的複製

目前的複製都在資料庫層，有時候想要更多選擇，例如只想要複製資料的一個子集，或是想從資料庫複製到另一種資料庫，或者需要解決衝突環境，可能需要將複製移動到應用層。

一些工具也是基於日誌實現這項功能，讓其他應用程序可以使用數據，另一中是使用許多關係性資料庫自帶的功能: trigger 和  stored procedures，trigger 允許在資料更新或是寫入時自動執行自訂義程序，儘管這種複製會比其他複製有更多的開銷也更容易出錯，但也濘靈活。

## 複製延遲問題

由於多數應用場景都是讀多寫少，因此開很多read only follower就可以簡單的提高服務容量，且只能使用異步，若是同步會造成單一節點故障後整個系統無法寫入的情況。

當程序從異步follower讀取時，如果follower落後，可能會看到過時的資訊: 對leader和follower執行相同的查詢得到不同的結果。這種不一致性只是一時的，最終從褲會追上主庫，稱為最終一致性。到底會延遲多久看狀況，一般來說應該不到一秒，但在網路或系統高負載的情況下，最終可能到達數分鐘之久。

本節將簡述三個複製延遲的例子並討論解決方法。

## 讀己之寫

如果用戶在寫入後馬上查詢，有可能新數據還沒到副本，對用戶而言看起來就是剛提交失敗。
![用戶寫入後從舊的副本讀取，需要寫後讀(read-after-write)的一致性防止異常](https://github.com/Vonng/ddia/blob/master/img/fig5-3.png)

這種情況下需要讀寫一致性(read after write consistency)，這是一種保證，如果用戶重新加載頁面，會看到自己提交的更新，但是對其他用戶的更新可能要稍等。這保證用戶對自己的輸入已被正確保存。

如何實現讀寫一致性? 以下說明一些:
- 讀用戶可能已經修改過的內容，例如個人檔案都只能由用戶本人編輯，因此一個簡單的做法是由主庫讀取用戶自己的檔案，在從庫讀取其他用戶的檔案。

- 如果大多數內容都可以被用戶編輯，上面的方法就不適用了。在這種情況下可以使用其他標準來決定是否從主庫讀取，例如可以跟蹤上次更新時間，在上次更新後的一分鐘內由主庫讀，還可以監控從庫的延遲複製，防止任意比主庫延遲超過一分鐘的從庫發出查詢。

- 客戶端可以記住最後一次寫入的時間，系統需要確保從庫最後更新時間大於最後一次寫入的時間，如果當前的從庫不夠新，就從其他從庫讀取或是等待從庫追上。

- 如果副本在多個數據中心，則會增加複雜性。任何需要領導者的服務都需要從路由道包含主庫的數據中心。

另外的情況下多種裝置，例如用戶同時使用手機和電腦，還需要提供跨設備的讀寫一致性，這種情況下讓用戶記住上一次更新時間更困難，元數據需要一個中心儲存資料。如果副本分布在不同數據中心，很難保證不同設備會接到同一個數據中心，如果需要讀主庫，要先把同一用戶的請求發送到同一個數據中心。

### 單調讀

另一個異常狀況是會碰到時光倒流(moving backward in time)。

在用戶從不同從庫中讀取，當從庫同步不一致時，就可能發生。
![用戶首先從新副本讀取，然後從舊副本讀取。時光倒流。為了防止這種異常，我們需要單調的讀取](https://github.com/Vonng/ddia/blob/master/img/fig5-4.png)

單調讀(Monotonic reads)保證這種異常不會發生。這是比強一致性(strong consistency)更弱，但比最終一致性(eventually consistency)更強的保證。當讀取資料時可能會看到一個舊值，單調讀取僅意味著一個鬨順序的進行多次讀取，他們不會看到時間退後: 如果之前讀到比較新的數據，之後不會得到更舊的數據。

實現的方法是確表同一個用戶總是從同一個副本讀取，例如透過用戶ID的散射選擇副本，在副本失敗時將會導到另一個副本。

### 一致前綴讀

有時因為某些分區的複製速度慢於其他區，會有順序亂掉的情況。

![如果某些分區的複制速度慢於其他分區，那麼觀察者在看到問題之前可能會看到答案。](https://github.com/Vonng/ddia/blob/master/img/fig5-5.png)

要防止這種異常需要另一種保證: 一致前綴讀(consistent prefix reads)，這個保證說，如果一系列寫入按這個順序發生，那麼任何人讀取時，也會看見以同樣的順序出現。

這是分區(partitioned)中的特殊問題，在許多分布式資料庫中，不同的分區獨立運行，因此不存在**全局寫入順序**，當用路從數據庫讀取時，某些部分處在比較舊，某些部分處在比較新。一種解決方案是，確保任何因果相關的寫入都寫入相同的分區。對於某些無法高效完成這種操作的應用，還有一些顯式跟踪因果依賴關係的算法。

### 複製延遲的解決方案

在最終一致性的系統中，如果複製延遲多達幾分鐘到幾小時，應該考慮應用程序的行為，因此設計系統來做出更強的保證是很重要的。在資料庫中這就是**事務(transaction)**存在的原因，資料庫透過事務提供強大的保證，所以應用程序會更簡單。

單節點事務能否在目前分散式資料庫中持續存在，第七章和第九章會回到這個話題討論一些代替機制。


## 多主複製

單一主庫的缺點是所有寫入都仰賴這個主庫，出於任何原因連接不到這個主庫的話，就無法進行寫入。基於領導者的複製模型的延伸式允許多個節點接受寫入，每個領導者同時扮演其他領導者的追隨者。

### 多主複製的應用場景

#### 運維多個數據中心

為了容忍單個數據中心的故障或使地理上更接近用戶，多領導中者配置在每個數據中心中都有主庫，每個數據中心的主庫都會將其更改複製到其他數據中心的主庫中。

![跨多個數據中心的多主複製](https://github.com/Vonng/ddia/blob/master/img/fig5-6.png)

##### 性能

體感會比單個主庫更好，因為每個寫操作都可以在本地的數據中心中進行，並與其他數據中心異步複製。

##### 容忍數據中心停機

在單主配置中，如果主庫的數據中心故障，故障切換會使另一個數據中心的從庫成為領導者。在多主配置中，每個數據中心是獨立的其他數據中心的。

##### 容忍網路問題

數據中心間的通信要通過外網，可能不如數據中心的內網來的可靠。單主配置對數據中心的連接問題很敏感在於，因為通過這個連接的血操作是同步的，而透過異步複製功能的多主配置通常能更好的承受網路問題: 臨時的網路中斷不會妨礙寫入。

儘管多主配置有這些優勢，但也有很大的缺點: 兩個不同的數據中心可能會同時修改相同的數據，造成寫入衝突。

#### 需要離線操作的客戶端

多主複製另一個適用場景是應用程序在斷網後仍然需要繼續工作。

例如很多手機都支援的離線查看，當在離線情況下修改，那下次連上網路時需要和其他設備同步。在這種情況下每個設備都有一個充當領導者的本地數據庫(允許寫入請求)，並在所有設備上的副本間同步時，存在異步的多主複製過程。複製延遲時間端看何時能連回網路。

#### 協同編輯

實作協同編輯，允許多人同時修改一份文件: 當一個用戶編輯時，所做的更改應該立即複製到本地副本以及異步複製到編輯同一份文檔的其他用戶。要保證不會發生衝突，應用程序需要先取得文件的鎖定，等到第一個用戶提交後並釋放鎖定。為了加速協作，可能會希望將更改的單位設置到非常小，並避免鎖定。

### 處理寫入衝突

多領導這最大的問題是可能發生衝突，意味著需要解決衝突。

例如考慮到一個由兩個用戶同時編輯的維基頁面，用戶一和用戶二隊同個地方做了更改，異步複製時會出現衝突。

![兩個主庫同時更新同一記錄引起的寫入衝突](https://github.com/Vonng/ddia/blob/master/img/fig5-7.png)

#### 同步與異步衝突檢測

在單主數據庫中，第二個寫入會被阻塞，等待第一個寫入完成或是直接中止第二個事務，強制用戶重試。在多主配置中，兩個寫入都是成功的，而且在稍後的時間點檢測到衝突，那時候要求客戶解決衝突可能已經太晚了。原則上可以使衝突檢測同度，但這樣做就喪失了多主複製的主要優點: 允許不同副本獨立接受寫入。

#### 避免衝突

由於許多多領導者複製處理衝突都實現的不好，因此建議是直接避免衝突，例如用戶可以編輯自己的數據的程序中，可以確保特定用戶的請求始終到同一個數據中心，並使用該數據中心的領導者進行讀寫。從用戶的角度看，配置基本上都是單一的領導者。

有時候需要更改指定的記錄的主庫，可能是原本的數據中心故障或是用戶已經遷移到另外的位置。在這種情況下衝突避免會中斷，必須處理不同主庫同時寫入的可能。

### 收斂至一致的狀態

單一數據庫按順序進行寫操作，最後值會是最後一個操作，在多主配置中，沒有明確的寫入順序，所以最終值應該是什麼並不清楚，如果每個副本只是按照他看到寫入的順序寫入，那最終一定會出現衝突，這是不可接受的。每個複製方案都必須確保數據在所有副本中最終一致，因為資料庫必須以一種收斂的方式解決衝突，這表示所有副本都必須在所有變更複製完成時收斂到相同的最終值。

實現衝突合併的方法:
- 給每個寫入一個唯一值，挑選最高ID的寫入作為勝利者，如果使用時間戳，這種技術稱為最後寫入勝利(LWW, last write wins)。雖然這種方法很流行，但很容易造成數據丟失。
- 為每個副本分配唯一的ID，ID更高的寫入具有更高的優先級，當然也會造成數據丟失。
- 以某種方式將衝突值合併在一起(這誰會用???????????)
- 用一種可保留所有信息的結構來記錄衝突，並編寫解決衝突的應用程序(也會叫工程師回來修)

### 自訂義衝突解決邏輯

#### 寫時執行
只要資料庫檢測到複製更改文件存在衝突，就會調用衝突處理程序。
#### 讀時執行
檢測到衝突時所有衝突寫入被儲存。下次讀取數據時會將多個版本的數據返回給應用程序，會提示用戶去解決衝突。

## 多主複製拓樸
複製拓樸(replication topology)描述寫入從一個節點 
